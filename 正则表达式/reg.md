
//(\b . * \d  \s \w 任意空白符 空格制表符 换行符 中文全角空格)
//  \s 匹配任意的空白符 包括空格 制表符 换行符 中文全角空格
//  \w 匹配字母或数字或下划线或汉字等

/*  /\ba\w*\b\/ 以字母a开头的单词 先是某个单词开始处(\b) 然后是字母a 然后是任意数量的字母或数字(\w*)
 *   最后是单词结束处(\b)。
 *   \d+ 匹配1个或更多连续的数字 这里的 + 和 * 类似的元字符。不同的是 * 匹配重复任意次
 *   \d+ ===> ( reg.test('1 || 11'); 大于等于1)
 *   \d* ===> ( reg.test() 大于等于0)
 */

var reg     =   /\ba\w*\b/,     //以字母a开头 然后是任意数量的字母或数字 最后单词结束
    reg1    =   /\b\w{6}\b/,    //匹配刚好6个字符的单词
    reg2    =   /^\d{5,12}$/;   //以字符串开头的5到12个数字之间的数字 以字符串结尾
                                //{5,12} 重复次数不能少于5次 不能多于12次
1> 常用的元字符
=====================
/*
 *  .   匹配除换行符以外的任意字符
 *  \w  匹配字母或数字或下划线或汉字
 *  \s  匹配任意的空白符
 *  \d  匹配数字
 *  \b  匹配单词的开始或结束
 *  ^   匹配字符串的开始
 *  $   匹配字符串的结束
 */

匹配3位数字          '/^\d{3}$/'     以字符开头 以字符结尾 限制3次数字
匹配3到5位的数字     '/^\d{3,5}$/'    以字符开头 以字符结尾 限制3到5次数字

2>  字符转义
====================
// 如果你想查找元字符本身的话 比如你查找 . 或者 * 就出现问题。 你没有办法指定他们。因为他们会被
// 解释为别的意思。这时候你得使用 \ 来取消这些字符的特殊意义。因此使用 \. 和 \* 当然查找\本身
// 也要用 \\ 例如: deerchao\.net  C:\\Windows 匹配 C:\Windows

3>  重复
===================
*、+、 {2}、 {5,12} 这几个匹配重复的方式 下面是正则表达式中所有的限定字符(指定数量的代码)

// *    重复零次或更多次
// +    重复一次或更多次
// ?    重复零次或一次
// {n}  重复n次
// {n,} 重复n次或更多次
// {n,m} 重复n到m次

Windows\d+ 匹配Windows后面跟1个或更多数字
^\w+       匹配一行的第一个单词 (或这个字符串的第一个单词 具体匹配哪个意思得看选项设置)

4>  字符类
===================
匹配任何一个没有预定义元字符的字符集合 使用括号 [aeiuo] [.?!]匹配标点符号。
字符范围 [0-9] 就等价于 \d "表示一个数字"  [a-z0-9A-Z]等价于 \w (如果只考虑英文)

/\(?0\d{2}[)-]?\d{8})/  表示一个座机号
" \(转义字符 表示括号出现一次或0次 然后是0 后面跟着2个数字 是括号[(-]？括号或是-或是空格中的一个"
" 出现一次或不出现 最后是8个数字 (\d{8})"
但是上面这个正则也能匹配 010)12345678 或者 (022-13213211 这样不正确的格式
    我们需要用到"分枝条件"

5> 分枝条件
==================
0\d{2}-\d{8}|0\d{3}-\d{8} :
\d{3}-\d{8}|\d{4}-{7,8}
这个正则可以匹配"以两种连字号分隔的电话号码 一种是三位区号 8位本地号 一种是4位区号 8位本地号"

\(?0\d{2}\)?[-]?\d{8}|0\d{2}[-]?\d{8}\
匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔

6> 分组
=================
(\d{1,3}\.){3}\d{1,3} 是一个简单的IP地址匹配表达式
\d{1,3} 匹配1到3位数字后面跟着转义字符.加上括号 (\d{1,3}\.){3}表示匹配三位数字加上一个英文句号.
这个就表示简单的分组 重复三次。最后再加上一个一到三位的数字 \d{1,3}。
但是也会匹配(255.300.222.999)这样的数字

正确的IP正则 : ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
"IP地址中每个数字都不能大于255. 经常有人问我, 01.02.03.04 这样前面带有0的数字,"
" 是不是正确的IP地址呢? 答案是: 是的, IP 地址里的数字可以包含有前导 0 (leading zeroes)."

7> 反义字符
==============
有时候需要查找不属于某个能简单定义的字符类的字符 比如查找除了数字以外 其他任意字符都行的情况 这时候就要反义
"(\W)"      匹配任意不是字母 数字 下划线 汉字的字符
"(\S)"      匹配任意不是空白符的字符
"(\D)"      匹配任意非数字的字符
"(\B)"      匹配不是单词开头或结束的位置
"[^x]"      匹配除了x以外的任意字符
"[^aeiou]"  匹配除了aeiou这几个字母以外的任意字符

8>  后向引用
==================
'匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。'
'默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，'
'第一个出现的分组的组号为1，第二个为2，以此类推'
'\b(\w+)\b\s+\1\b' 用来匹配可以重复的单词 go go  kitty kitty
 \b(\w+)\b '单词开始处和结束处 之间多于一个字母或数字 这个单词会被捕获到编号'
 '为1的分组中然后是1个或几个空白符(\s+) 最后是分组1中捕获的内容'

 指定一个子表达式的组名  这使用这样的语法 : (?<Word>\w+) 或者 (?'Word'\w+)

 常用分组语法

 '(exp)'        匹配exp 捕获文本到自动命名的组里
 '(?<name>exp)' 匹配exp 并捕获文本到名称为name的组里 也可以写成(?'name'exp)
 '(?:exp)'      匹配exp 不捕获匹配的文本 也不给此分组分配组号

零宽断言
 =============
 '(?=exp)'      匹配exp前面的位置
 '(?<=exp)'     匹配exp后面的位置
 '(?!exp)'      匹配后面跟的不是exp的位置
 '(?<!exp)'     匹配前面不是exp的位置

注释
==============
'(?#comment)' 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读


零宽断言
===============

\b、^、$ 用于指定一个位置 这个位置应该满足一定的条件 因此他们被零宽断言
(?=exp) 也叫做零宽度正预测先行断言比如
'\b\w+(?=ing\b)' 匹配以ing结尾的单词前面部分除了ing以外的部分'learn'ing

(?<=exp)            零宽度正回顾后发断言 断言自身出现的位置前面能匹配表达式exp
'(?<=\bre)\w+\b'    匹配以re开头的单词的后半部分(除了re以外的部分) re'ading'

负向零宽断言
================
怎么查找'不是某个字符或不在某个字符类里'的字符串 只是想确保某个字符没有出现 并不想去匹配。

'\b\w*q(?!u)\w*\b' 只匹配一个位置 不消费任何字符
(?!exp) 断言此位置的后面不能匹配表达式exp。 例如:
' \d{3}(?!\d) '         匹配三位数字 这三位数字后面不能是数字;
' \b((?!abc)\w)+\b\ '   匹配不包含连续字符串abc的单词
' (?<![a-z]\d{7}) '     匹配'前面不是小写字母的七位数字'
' (?<=<(\w+)>).*(?=<\/\1>) '    匹配不包含属性的简单HTML标签内里的内容
分解 ' (?<=<(\w+)>) '     指定了 '被尖括号括起来的单词'
    ' .* '                (任意的字符串)
    ' (?=<\/\1>) '         转义字符 \/   \1是反向引用 前面的如果是<b>  那么后面的就是</b>重复前面的
'整个正则就是说' <b></b>之间的内容

注释
=============
小括号的注释 (?#comment)
2[0-4]\d(?#200-240) 匹配200-240

'(?<='     # 断言要匹配的文本的前缀
'<(\w+)>'  # 查找尖括号扩起来的字母或数字
')'        # 前缀结束
'.*'       # 匹配任意文本
'(?=)'     # 断言要匹配的文本的后缀
'<\/\1>'   # 查找尖括号括起来的内容 前面是一个 "/" 后面是先前捕获的标签
')'        # 后缀结束

懒惰限定符
=============

'*?'        重复任意次 但尽可能少重复
'+?'        重复一次或更多次 尽量少重复
'??'        重读0次或1次 但尽可能少重复
'{n,m}?'    重复n到m次 但尽可能少重复
'{n}?'      重复n次以上 但尽可能少重复


常用的正则表达式
=============================

匹配中文字符 :                    '/[\u4e00-\u9fa5]/'
匹配双字节字符(包括汉字在内)       '/[^\x00-\xff]/'
匹配空白行                        '/\n\s*\r/'
匹配Email地址  /[\w!#$%&'*+/=?^_`{|}~-]+(?:\.[\w!#$%&'*+/=?^_`{|}~-]+)*@(?:[\w](?:[\w-]*[\w])?\.)+[\w](?:[\w-]*[\w])?/
匹配网址URL                         '/[a-zA-z]+://[^\s]*/'
匹配国内电话号码                    '\d{3}-\d{8}|\d{4}-\d{7,8}'
匹配腾讯QQ号                     '[1-9][0-9]{4,}'
中国邮政编码                      '/[1-9]\d{5}(?!\d)/'
匹配18位身份证号码                 '/^(\d{6})(\d{4})(\d{2})(\d{2})(\d{3})([0-9]|X)$/'
匹配年月日格式                     '/([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8])))/'
