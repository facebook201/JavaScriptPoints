#### 正则表达式基础字符



#### 修饰符

| 字符 | 描述                                                   |
| ---- | ------------------------------------------------------ |
| g    | global 全局匹配 只有匹配成功的结果一直匹配直到没有为止 |
| i    | ignoreCase 忽略大小写                                  |
| m    | multiline 多行匹配                                     |





####元字符

| 字符     | 描述                                                         |
| :------- | ------------------------------------------------------------ |
| \n       | 匹配换行符 等价于 \x0a 和 \cJ                                |
| \s       | 匹配任何空白字符 包括空格 制表符 换页符 (\s 和 \S可以记为 space) |
| \S       | 匹配任何非空白字符                                           |
| \        | 转义字符                                                     |
| .        | 除了换行符之外的任意字符                                     |
| \d       | 匹配0-9之间的数字                                            |
| \D       | 匹配非0-9之间的字符                                          |
| \w       | 匹配0-9或字母或_之间的一个字符                               |
| \b       | 匹配一个边界字符                                             |
| x \| y   | 匹配x 或者 y中的一个 ( 如果 x \| ) 就匹配 x 或者不匹配       |
| [a - z ] | 匹配 a - z 中任意的一个字符                                  |
| [^a - z] | 匹配非 a - z中的任何一个字符                                 |
| [xyz]    | 匹配x或y或z中的一个字符                                      |
| [^xyz]   | 匹配非xyz中的任何一个字符                                    |
| ()       | 分组匹配 可以理解为一个小分组 大正则里面的小正则匹配         |
| ^        | 以一个元字符开始                                             |
| $        | 以一个元字符结束                                             |
| ?:       | 只匹配不捕获                                                 |
| ?=       | 正向肯定预                                                   |
| ?!       | 正向否定预查                                                 |



#### 量词

| 字符  | 描述                         |
| ----- | ---------------------------- |
| +     | 让前面的元字符出现一次到多次 |
| ？    | 出现0次到一次                |
| *     | 出现0次到多次                |
| {n}   | 出现n次                      |
| {n,}  | 出现n次到多次                |
| {n,m} | 出现n次到m次                 |









**边界字符的匹配有点难理解**

> \b 
>
> \B
>
>  ?:
>
> ?+
>
> ?!



#### 重点补充

匹配字符 在 [ ] 中的特殊元字符一般代表着本身含义

```javascript
const reg = /^[.?+&]$/; // 代表匹配 . ? + &
```



#### 元字符



* 1 开始元字符 ^

  > 匹配起始位置的元字符 表示开头必须是 2 如果开始元字符放在 []里面 表示非中括号情况



* 2  结束元字符 $

  > 匹配结束位置的元字符 

* 3 分组引用  \n

  > 分组引用的概念就是引用大正则中指定的小正则 

  ```javascript
  const reg = /^([a-z])([a-z])\2([a-z])$/;
  // 匹配 book week http
  ```

  \2 就代表着 第二个小正则的完全引用 就是和第二个一样 减少正则的复杂度和处理多次重复规则



* 4 边界符 \b

  > 匹配单词边界 也就是指单词和空格间的位置 边界主要是单词的左右两边 

  ```javascript
  const reg = /er\b/;
  
  let txt = 'never'; // 这样就可以匹配到er 应该er后面没有其他字符 是属于边界位置
  let txt1 = 'verb'; // 这样就不能匹配到
  
  const reg = /er\B/;
  
  let txt2 = 'never'; // 这样er后面没有字符 属于边界 \B 就匹配不到
  let text3 = 'nevergiveup'; // 这样就可以匹配到er 非边界 不是单词和空格
  ```

* 5 只匹配不捕获 ?:

  ```javascript
  const reg = /^(\d{6})(?:\d{4})(\d{2})$/;
  
  reg.exec('340826199308'); // 340826 08 只匹配 不捕获
  
  ```

* 6 正向肯定预查 ?=

  为匹配一个元素后面是的元素是否符合相应规则 但是不消耗这个规则。

```javascript
var reg = /windows(?=95|98|NT|2000)/g;


reg.test('windows2000'); // true
reg.test('windowsxp'); // false

console.log(reg.exec(str1)); // 捕获到window2000 并且捕获结果没有带上2000
console.log(reg.exec(str)); // 这里就捕获失败 返回 null


// 例子二
const reg1 = /win(?=d)dows/;
const reg2 = /win(d)dows/;

reg1.test('windows'); // 这里匹配到 d 但是不消耗d 值匹配 不捕获他
reg2.test('windows'); // 这里匹配失败 要匹配的是 winddows

```





* 
* 





































