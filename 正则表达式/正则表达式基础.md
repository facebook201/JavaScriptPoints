#### 正则表达式基础字符



#### 修饰符

| 字符 | 描述                                                   |
| ---- | ------------------------------------------------------ |
| g    | global 全局匹配 只有匹配成功的结果一直匹配直到没有为止 |
| i    | ignoreCase 忽略大小写                                  |
| m    | multiline 多行匹配                                     |





####元字符

| 字符     | 描述                                                         |
| :------- | ------------------------------------------------------------ |
| \n       | 匹配换行符 等价于 \x0a 和 \cJ                                |
| \s       | 匹配任何空白字符 包括空格 制表符 换页符 (\s 和 \S可以记为 space) |
| \S       | 匹配任何非空白字符                                           |
| \        | 转义字符                                                     |
| .        | 除了换行符之外的任意字符                                     |
| \d       | 匹配0-9之间的数字                                            |
| \D       | 匹配非0-9之间的字符                                          |
| \w       | 匹配0-9或字母或_之间的一个字符                               |
| \b       | 匹配一个边界字符                                             |
| x \| y   | 匹配x 或者 y中的一个 ( 如果 x \| ) 就匹配 x 或者不匹配       |
| [a - z ] | 匹配 a - z 中任意的一个字符                                  |
| [^a - z] | 匹配非 a - z中的任何一个字符                                 |
| [xyz]    | 匹配x或y或z中的一个字符                                      |
| [^xyz]   | 匹配非xyz中的任何一个字符                                    |
| ()       | 分组匹配 可以理解为一个小分组 大正则里面的小正则匹配         |
| ^        | 以一个元字符开始                                             |
| $        | 以一个元字符结束                                             |
| ?:       | 只匹配不捕获                                                 |
| ?=       | 正向肯定预                                                   |
| ?!       | 正向否定预查                                                 |



#### 量词

| 字符  | 描述                         |
| ----- | ---------------------------- |
| +     | 让前面的元字符出现一次到多次 |
| ？    | 出现0次到一次                |
| *     | 出现0次到多次                |
| {n}   | 出现n次                      |
| {n,}  | 出现n次到多次                |
| {n,m} | 出现n次到m次                 |









**边界字符的匹配有点难理解**

> \b 
>
> \B
>
>  ?:
>
> ?+
>
> ?!



#### 重点补充

匹配字符 在 [ ] 中的特殊元字符一般代表着本身含义

```javascript
const reg = /^[.?+&]$/; // 代表匹配 . ? + &
```



#### 元字符



* 1 开始元字符 ^

  > 匹配起始位置的元字符 表示开头必须是 2 如果开始元字符放在 []里面 表示非中括号情况



* 2  结束元字符 $

  > 匹配结束位置的元字符 

* 3 分组引用  \n

  > 分组引用的概念就是引用大正则中指定的小正则 

  ```javascript
  const reg = /^([a-z])([a-z])\2([a-z])$/;
  // 匹配 book week http
  ```

  \2 就代表着 第二个小正则的完全引用 就是和第二个一样 减少正则的复杂度和处理多次重复规则



* 4 边界符 \b

  > 匹配单词边界 也就是指单词和空格间的位置 边界主要是单词的左右两边 

  ```javascript
  const reg = /er\b/;
  
  let txt = 'never'; // 这样就可以匹配到er 应该er后面没有其他字符 是属于边界位置
  let txt1 = 'verb'; // 这样就不能匹配到
  
  const reg = /er\B/;
  
  let txt2 = 'never'; // 这样er后面没有字符 属于边界 \B 就匹配不到
  let text3 = 'nevergiveup'; // 这样就可以匹配到er 非边界 不是单词和空格
  ```

* 5 只匹配不捕获 ?:

  ```javascript
  const reg = /^(\d{6})(?:\d{4})(\d{2})$/;
  
  reg.exec('340826199308'); // 340826 08 只匹配 不捕获
  
  ```

* 6 正向肯定预查 ?=

  为匹配一个元素后面是的元素是否符合相应规则 但是不消耗这个规则。

```javascript
var reg = /windows(?=95|98|NT|2000)/g;


reg.test('windows2000'); // true
reg.test('windowsxp'); // false

console.log(reg.exec(str1)); // 捕获到window2000 并且捕获结果没有带上2000
console.log(reg.exec(str)); // 这里就捕获失败 返回 null


// 例子二
const reg1 = /win(?=d)dows/;
const reg2 = /win(d)dows/;

reg1.test('windows'); // 这里匹配到 d 但是不消耗d 值匹配 不捕获他
reg2.test('windows'); // 这里匹配失败 要匹配的是 winddows

```





#### 反义

| 语法     | 描述                                        |
| -------- | ------------------------------------------- |
| \W       | 匹配任意不是字母 数字 下划线 汉字的字符     |
| \S       | 匹配任意不是空白符的字符                    |
| \D       | 匹配任意非数字的字符                        |
| \B       | 匹配不是单词开头或结束的位置 匹配非边界位置 |
| [^X]     | 匹配除了X以外的任意字符                     |
| [^aeiou] | 匹配除了aeiou以外的任意字符                 |



<a[^>\] + > 匹配用尖括号括起来的以a开头的字符串。



#### 分组语法

| 分类     | 语法           | 说明                                                    |
| -------- | -------------- | ------------------------------------------------------- |
| 捕获     | (exp)          | 匹配exp 捕获文本到自动命名的组里                        |
|          | (?<\name\>exp) | 匹配exp 并捕获文本到名称为name的组 可以写成 (?name'exp) |
|          | (?:exp)        | 匹配 但是不捕获                                         |
| 零宽断言 | （?=exp）      | 匹配exp前面的位置                                       |
|          | (?<=exp)       | 匹配exp后面的位置                                       |
|          | (?!exp)        | 匹配后面跟的不是exp的位置                               |
|          | (?<!exp)       | 匹配前面不是exp的位置                                   |
|          |                |                                                         |
|          |                |                                                         |



#### 零宽断言 

接下来的四个用于查找某些内容之前或之后的东西。 就像\b ^ $ 用于指定一个位置。这个位置满足一定的条件 因此也被称为零宽断言。

（?=exp）**它断言自身出现的位置的后面能匹配表达式exp，比如\b\w+(?=ing)\b 匹配以ing结尾的单词的前面部分**

(?<=exp) **匹配自身出现的位置的前面能匹配表达式 **



#### 贪婪与懒惰

当正则表达式中包含能接受重复的限定符。通常的行为是

贪婪：**尽可能的匹配多的字符**

惰性：**尽可能的少匹配字符**

**?加上一个问号 就意味着在匹配成功的前提下 尽量使用最少的重复。** 

a.?b 匹配最短。 匹配aabab 以a开始 以b结束。所以会匹配到 aab 和 ab。为什么不是ab ab。因为**最先开始的匹配拥有最高的优先权**



| 代码/语法 | 说明                            |
| --------- | ------------------------------- |
| *?        | 重复任意次，但尽可能少重复      |
| +?        | 重复1次或更多次，但尽可能少重复 |
| ??        | 重复0次或1次，但尽可能少重复    |
| {n,m}?    | 重复n到m次，但尽可能少重复      |
| {n,}?     | 重复n次以上，但尽可能少重复     |





























